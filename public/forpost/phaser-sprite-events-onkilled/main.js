
var Enemy = {};

// setup a game.data object
Enemy.setup = function () {

    this.game.data = {

        maxEnemies: 5,
        enemies: null,
        score: 0

    };

};

// The onKill method that will be called each time an enemy is killed
Enemy.onKill = function (sprite) {

    var game = this.game,
    spriteSpeed = (sprite.data.dx + sprite.data.dy) / 8,
    speedBonus = 175, // points bonus for speed.
    perKill = 25; // points per kill

    // score formula
    game.data.score += perKill + Math.floor(spriteSpeed * speedBonus);

};

// What happens when the player clicks an enemy
Enemy.onInputDown = function (enemy) {

    enemy.data.hp -= 1;

    if (enemy.data.hp === 1) {

        enemy.frame = 1;

    }

    if (enemy.data.hp <= 0) {

        enemy.kill();

    }

};

// generate a data object for a sprite
Enemy.genSpriteData = function () {

    return {
        dx: Math.random() * 3.5 + 0.5,
        dy: Math.random() * 3.5 + 0.5,
        hp: 2
    };

};

// make a sprite sheet
Enemy.mkSheet = function (game) {

    // sprite sheet generated by canvas
    var canvas = document.createElement('canvas'),
    ctx = canvas.getContext('2d');
    canvas.width = 64;
    canvas.height = 32;

    // blue frame
    ctx.fillStyle = '#0000ff';
    ctx.fillRect(0, 0, 32, 32);

    // red frame
    ctx.fillStyle = '#ff0000';
    ctx.fillRect(32, 0, 32, 32);

    game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);

};

// create a group of enemies
Enemy.createEnemyPool = function () {

    var i = 0,
    data = this.game.data;

    // make data.enemies a new group
    data.enemies = game.add.group();

    // make a pool of enemies in the group
    while (i < data.maxEnemies) {

        var enemy = data.enemies.create(0, 0, 'sheet-block');

        // enemy starts out killed
        enemy.kill();

        // attach onKilled event
        enemy.events.onKilled.add(Enemy.onKill, this);

        // attach on input down event
        enemy.inputEnabled = true;
        enemy.events.onInputDown.add(Enemy.onInputDown, this);

        i += 1;

    }

};

// re-spawn a dead enemy
Enemy.spawn = function (a) {

    var enemies = this.game.data.enemies;

    var dead = enemies.getFirstDead(false, 0, 0, 'sheet-block', 0);

    // if there is
    if (dead) {

        dead.data = Enemy.genSpriteData();

    }

};

Enemy.update = function () {

    var data = this.game.data,
    game = this.game;

    data.enemies.forEach(function (enemy) {

        enemy.x = Phaser.Math.wrap(enemy.x += enemy.data.dx, -32, game.world.width + 32);
        enemy.y = Phaser.Math.wrap(enemy.y += enemy.data.dy, -32, game.world.height + 32);

    });

};

var game = new Phaser.Game(320, 240, Phaser.AUTO, 'gamearea');

game.state.add('boot', {

    create: function () {

        // setup game data object
        Enemy.setup.call(this);

        Enemy.mkSheet(this.game);

        Enemy.createEnemyPool.call(this);

        // start demo, and do not clear the world
        game.state.start('demo', false, false);

    }

});

game.state.add('demo', {

    create: function () {

        // call Enemy.spawn every second
        game.time.events.loop(1000, Enemy.spawn, this);

        // text display object to show score
        var text = game.add.text(5, 5, '', {
                fill: 'white'
            });
        text.name = 'disp-score';

    },

    update: function () {

        var data = this.game.data;

        Enemy.update.call(this);

        game.world.getByName('disp-score').text = 'score: ' + data.score;

    }

});

game.state.start('boot');
