// the main game variable
var game = new Phaser.Game(320, 240, Phaser.AUTO, 'gamearea');

game.global = {

    block_pool_size: 12,
    player: {}

};

game.state.add('boot', {

    create: function () {

        // sprite sheet generated by canvas
        var canvas = document.createElement('canvas'),
        ctx = canvas.getContext('2d');
        canvas.width = 64;
        canvas.height = 32;

        // blue frame
        ctx.fillStyle = '#0000ff';
        ctx.fillRect(0, 0, 32, 32);

        // red frame
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(32, 0, 32, 32);

        game.cache.addSpriteSheet('sheet-block', null, canvas, 32, 32, 2, 0, 0);

        game.global.centerPoint = new Phaser.Point(game.world.centerX, game.world.centerY);

        game.state.start('game');

    }

});

// Block module, for all things block related
var Block = {

    // create the block pool
    createBlockPool: function () {

        var i = 0,
        len = game.global.block_pool_size,
        sprite;
        while (i < len) {

            sprite = game.add.sprite(-32, -32, 'sheet-block', 0);
            sprite.name = 'block-' + i;
            sprite.data = {
                state: 'inactive',
                heading: 0,
                dx: 1,
                dy: 0,
                hp: 1,
                i: 0
            };
            i += 1;

        }

    },

    // what to do if a block is clicked
    onClick: function (block) {

        block.data.hp -= 1;

        if (block.data.hp <= 0) {

            block.data.state = 'dead';

        }

    },

    // update methods for each block state
    updateStates: {

        // the block is inactive, and outside the world
        inactive: function (sprite) {

            sprite.data.state = 'inbound';
            sprite.alpha = 1;
            sprite.frame = 0;
            a = Math.PI * 2 * Math.random();

            var spawnPt = new Phaser.Point(
                    Math.cos(a) * (game.world.width) + game.world.centerX - sprite.width / 2,
                    Math.sin(a) * (game.world.height) + game.world.centerY - sprite.height / 2);

            sprite.x = spawnPt.x;
            sprite.y = spawnPt.y;

            sprite.data.heading = spawnPt.angle(game.global.centerPoint);
            sprite.data.dx = Math.cos(sprite.data.heading);
            sprite.data.dy = Math.sin(sprite.data.heading);

            sprite.inputEnabled = true;

            // if a block is clicked
            sprite.events.onInputDown.add(Block.onClick);

        },

        // the block is inbound from outside the world, into the world
        inbound: function (sprite) {

            sprite.x += sprite.data.dx;
            sprite.y += sprite.data.dy;

            var d = game.global.centerPoint.distance(sprite);

            // if close to the center set active
            if (d < 100) {

                sprite.data.state = 'active';

            }

        },

        // the block is actively moving
        active: function (sprite) {

            sprite.x += sprite.data.dx;
            sprite.y += sprite.data.dy;

            // make sure block is in the game area
            sprite.x = Phaser.Math.wrap(sprite.x, -32, game.world.width + 32);
            sprite.y = Phaser.Math.wrap(sprite.y, -32, game.world.height + 32);

        },

        // the block is dead, at this time a death animation just plays
        dead: function (sprite) {

            sprite.alpha = (100 - sprite.data.i) / 100;
            sprite.frame = 1;

            if (sprite.data.i >= 100) {

                sprite.data.i = 0;
                sprite.data.state = 'inactive';
                sprite.x = -32;
                sprite.y = -32;

            }

            sprite.data.i += 1;

        }

    },

    updateBlockSprite: function (sprite) {}

};

// the game state
game.state.add('game', {

    create: function () {

        Block.createBlockPool();

    },

    update: function () {

        var i = 0,
        len = game.global.block_pool_size,
        a,
        sprite;

        // loop all blocks
        while (i < len) {

            // grab sprite
            sprite = game.world.getByName('block-' + i);

            // call update methods for current state
            Block.updateStates[sprite.data.state](sprite);

            i += 1;
        }

    }

});

game.state.start('boot');
